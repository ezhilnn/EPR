package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/ezhilnn/epr-backend/internal/models"
	"github.com/ezhilnn/epr-backend/internal/utils"
	"github.com/jung-kurt/gofpdf"
)

// PDFService handles PDF generation for bills
type PDFService struct {
	frontendURL string
}

// NewPDFService creates a new PDF service
func NewPDFService(frontendURL string) *PDFService {
	return &PDFService{
		frontendURL: frontendURL,
	}
}

// GenerateBillPDF generates a PDF for a bill and returns the PDF bytes
func (s *PDFService) GenerateBillPDF(bill *models.Bill) ([]byte, error) {
	// Create new PDF
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set margins
	pdf.SetMargins(20, 20, 20)
	pdf.SetAutoPageBreak(true, 20)

	// Add watermark at the bottom
	s.addWatermark(pdf)

	// Add header with issuer info
	s.addHeader(pdf, bill)

	// Add bill info section
	s.addBillInfo(pdf, bill)

	// Parse bill_data
	var billData map[string]interface{}
	if err := json.Unmarshal(bill.BillData, &billData); err != nil {
		return nil, fmt.Errorf("failed to parse bill data: %w", err)
	}

	// Add bill details based on type
	s.addBillDetails(pdf, bill.BillType, billData)

	// Add amount section
	s.addAmountSection(pdf, bill)

	// Add QR code for verification
	if err := s.addQRCode(pdf, bill.BillNumber); err != nil {
		// Log error but don't fail - QR is optional
		fmt.Printf("Warning: Failed to add QR code: %v\n", err)
	}

	// Add footer with verification info
	s.addFooter(pdf, bill)

	// Get PDF bytes
	// var buf []byte
	// pdfBytes := pdf.Output(func(data []byte) {
	// 	buf = data
	// })
	
	// if pdfBytes != nil {
	// 	return nil, fmt.Errorf("failed to generate PDF output")
	// }

	// return buf, nil
	var buf bytes.Buffer

if err := pdf.Output(&buf); err != nil {
	return nil, fmt.Errorf("failed to generate PDF output: %w", err)
}

return buf.Bytes(), nil
}

// addWatermark adds EPR watermark at the bottom
func (s *PDFService) addWatermark(pdf *gofpdf.Fpdf) {
	pdf.SetY(-15)
	pdf.SetFont("Arial", "I", 8)
	pdf.SetTextColor(150, 150, 150)
	pdf.CellFormat(0, 10, "Generated by EPR (Electronic Public Records) | Â© 2025 All Rights Reserved", "", 0, "C", false, 0, "")
	pdf.SetTextColor(0, 0, 0) // Reset color
}

// addHeader adds company/issuer header
func (s *PDFService) addHeader(pdf *gofpdf.Fpdf, bill *models.Bill) {
	// Company/Issuer name - Large and bold
	pdf.SetFont("Arial", "B", 18)
	pdf.SetTextColor(31, 78, 120) // Professional blue color
	pdf.CellFormat(0, 10, bill.IssuerName, "", 1, "C", false, 0, "")
	
	pdf.SetTextColor(0, 0, 0) // Reset to black
	pdf.Ln(3)

	// Bill type as subtitle
	pdf.SetFont("Arial", "B", 14)
	billTypeDisplay := s.formatBillType(bill.BillType)
	pdf.CellFormat(0, 8, billTypeDisplay, "", 1, "C", false, 0, "")
	
	pdf.Ln(5)
	
	// Horizontal line
	pdf.SetDrawColor(200, 200, 200)
	pdf.Line(20, pdf.GetY(), 190, pdf.GetY())
	pdf.Ln(8)
}

// addBillInfo adds bill number, date, etc.
func (s *PDFService) addBillInfo(pdf *gofpdf.Fpdf, bill *models.Bill) {
	pdf.SetFont("Arial", "", 10)
	
	// Bill Number
	pdf.SetFont("Arial", "B", 10)
	pdf.Cell(50, 6, "Bill Number:")
	pdf.SetFont("Arial", "", 10)
	pdf.Cell(0, 6, bill.BillNumber)
	pdf.Ln(6)
	
	// Issue Date
	pdf.SetFont("Arial", "B", 10)
	pdf.Cell(50, 6, "Issue Date:")
	pdf.SetFont("Arial", "", 10)
	pdf.Cell(0, 6, bill.IssueDate.Format("02 January 2006"))
	pdf.Ln(6)
	
	// Access Level (if not public)
	if bill.AccessLevel != models.AccessLevelPublic {
		pdf.SetFont("Arial", "B", 10)
		pdf.Cell(50, 6, "Access Level:")
		pdf.SetFont("Arial", "", 10)
		pdf.SetTextColor(200, 0, 0)
		pdf.Cell(0, 6, string(bill.AccessLevel))
		pdf.SetTextColor(0, 0, 0)
		pdf.Ln(6)
	}
	
	pdf.Ln(5)
}

// addBillDetails adds the main bill content
func (s *PDFService) addBillDetails(pdf *gofpdf.Fpdf, billType models.BillType, data map[string]interface{}) {
	pdf.SetFont("Arial", "B", 12)
	pdf.SetFillColor(240, 240, 240)
	pdf.CellFormat(0, 8, "Bill Details", "", 1, "L", true, 0, "")
	pdf.Ln(3)
	
	pdf.SetFont("Arial", "", 10)
	
	// Generic fields that appear in most bills
	s.addFieldIfExists(pdf, "Recipient Name", data, "recipient_name")
	s.addFieldIfExists(pdf, "Recipient Email", data, "recipient_email")
	s.addFieldIfExists(pdf, "Recipient Phone", data, "recipient_phone")
	s.addFieldIfExists(pdf, "Description", data, "description")
	
	// Type-specific fields
	switch billType {
	case models.BillTypeSalarySlip:
		s.addSalarySlipDetails(pdf, data)
	case models.BillTypeSalesInvoice, models.BillTypePurchaseInvoice:
		s.addInvoiceDetails(pdf, data)
	case models.BillTypeMedicalBill:
		s.addMedicalBillDetails(pdf, data)
	case models.BillTypeRentReceipt:
		s.addRentReceiptDetails(pdf, data)
	default:
		// For other types, just show all data as key-value pairs
		s.addGenericDetails(pdf, data)
	}
	
	pdf.Ln(5)
}

// addFieldIfExists adds a field if it exists in data
func (s *PDFService) addFieldIfExists(pdf *gofpdf.Fpdf, label string, data map[string]interface{}, key string) {
	if val, exists := data[key]; exists && val != nil {
		pdf.SetFont("Arial", "B", 10)
		pdf.Cell(60, 6, label+":")
		pdf.SetFont("Arial", "", 10)
		pdf.MultiCell(0, 6, fmt.Sprintf("%v", val), "", "L", false)
	}
}

// addSalarySlipDetails adds salary slip specific details
func (s *PDFService) addSalarySlipDetails(pdf *gofpdf.Fpdf, data map[string]interface{}) {
	s.addFieldIfExists(pdf, "Employee ID", data, "employee_id")
	s.addFieldIfExists(pdf, "Employee Name", data, "employee_name")
	s.addFieldIfExists(pdf, "Designation", data, "designation")
	s.addFieldIfExists(pdf, "Department", data, "department")
	s.addFieldIfExists(pdf, "Month", data, "month")
	
	// Earnings section
	if earnings, ok := data["earnings"].(map[string]interface{}); ok {
		pdf.Ln(3)
		pdf.SetFont("Arial", "B", 11)
		pdf.Cell(0, 7, "Earnings")
		pdf.Ln(7)
		
		pdf.SetFont("Arial", "", 10)
		for key, val := range earnings {
			pdf.Cell(80, 6, s.formatFieldName(key)+":")
			pdf.Cell(0, 6, fmt.Sprintf("%.2f", val))
			pdf.Ln(6)
		}
	}
	
	// Deductions section
	if deductions, ok := data["deductions"].(map[string]interface{}); ok {
		pdf.Ln(3)
		pdf.SetFont("Arial", "B", 11)
		pdf.Cell(0, 7, "Deductions")
		pdf.Ln(7)
		
		pdf.SetFont("Arial", "", 10)
		for key, val := range deductions {
			pdf.Cell(80, 6, s.formatFieldName(key)+":")
			pdf.Cell(0, 6, fmt.Sprintf("%.2f", val))
			pdf.Ln(6)
		}
	}
}

// addInvoiceDetails adds invoice specific details
func (s *PDFService) addInvoiceDetails(pdf *gofpdf.Fpdf, data map[string]interface{}) {
	s.addFieldIfExists(pdf, "Invoice Number", data, "invoice_number")
	s.addFieldIfExists(pdf, "Customer Name", data, "customer_name")
	s.addFieldIfExists(pdf, "Customer Address", data, "customer_address")
	s.addFieldIfExists(pdf, "GSTIN", data, "gstin")
	
	// Line items table
	if items, ok := data["line_items"].([]interface{}); ok && len(items) > 0 {
		pdf.Ln(5)
		s.addLineItemsTable(pdf, items)
	}
}

// addMedicalBillDetails adds medical bill specific details
func (s *PDFService) addMedicalBillDetails(pdf *gofpdf.Fpdf, data map[string]interface{}) {
	s.addFieldIfExists(pdf, "Patient Name", data, "patient_name")
	s.addFieldIfExists(pdf, "Patient ID", data, "patient_id")
	s.addFieldIfExists(pdf, "Doctor Name", data, "doctor_name")
	s.addFieldIfExists(pdf, "Treatment", data, "treatment")
	s.addFieldIfExists(pdf, "Admission Date", data, "admission_date")
	s.addFieldIfExists(pdf, "Discharge Date", data, "discharge_date")
}

// addRentReceiptDetails adds rent receipt specific details
func (s *PDFService) addRentReceiptDetails(pdf *gofpdf.Fpdf, data map[string]interface{}) {
	s.addFieldIfExists(pdf, "Tenant Name", data, "tenant_name")
	s.addFieldIfExists(pdf, "Property Address", data, "property_address")
	s.addFieldIfExists(pdf, "Month", data, "month")
	s.addFieldIfExists(pdf, "Payment Mode", data, "payment_mode")
}

// addGenericDetails adds all data as key-value pairs
func (s *PDFService) addGenericDetails(pdf *gofpdf.Fpdf, data map[string]interface{}) {
	// Skip metadata
	for key, val := range data {
		if key == "_metadata" {
			continue
		}
		
		// Handle nested objects as JSON string
		valStr := ""
		switch v := val.(type) {
		case map[string]interface{}, []interface{}:
			jsonBytes, _ := json.MarshalIndent(v, "", "  ")
			valStr = string(jsonBytes)
		default:
			valStr = fmt.Sprintf("%v", v)
		}
		
		pdf.SetFont("Arial", "B", 10)
		pdf.Cell(60, 6, s.formatFieldName(key)+":")
		pdf.SetFont("Arial", "", 10)
		pdf.MultiCell(0, 6, valStr, "", "L", false)
	}
}

// addLineItemsTable adds a table for line items
func (s *PDFService) addLineItemsTable(pdf *gofpdf.Fpdf, items []interface{}) {
	pdf.SetFont("Arial", "B", 10)
	pdf.CellFormat(0, 8, "Items", "", 1, "L", false, 0, "")
	pdf.Ln(2)
	
	// Table header
	pdf.SetFillColor(230, 230, 230)
	pdf.SetFont("Arial", "B", 9)
	pdf.CellFormat(80, 7, "Description", "1", 0, "L", true, 0, "")
	pdf.CellFormat(30, 7, "Quantity", "1", 0, "C", true, 0, "")
	pdf.CellFormat(30, 7, "Rate", "1", 0, "R", true, 0, "")
	pdf.CellFormat(30, 7, "Amount", "1", 1, "R", true, 0, "")
	
	// Table rows
	pdf.SetFont("Arial", "", 9)
	for _, item := range items {
		if itemMap, ok := item.(map[string]interface{}); ok {
			desc := s.getStringValue(itemMap, "item", "description", "name")
			qty := s.getFloatValue(itemMap, "quantity", "qty")
			rate := s.getFloatValue(itemMap, "rate", "price", "unit_price")
			amount := s.getFloatValue(itemMap, "amount", "total")
			
			pdf.CellFormat(80, 6, desc, "1", 0, "L", false, 0, "")
			pdf.CellFormat(30, 6, fmt.Sprintf("%.2f", qty), "1", 0, "C", false, 0, "")
			pdf.CellFormat(30, 6, fmt.Sprintf("%.2f", rate), "1", 0, "R", false, 0, "")
			pdf.CellFormat(30, 6, fmt.Sprintf("%.2f", amount), "1", 1, "R", false, 0, "")
		}
	}
}

// addAmountSection adds the total amount section
func (s *PDFService) addAmountSection(pdf *gofpdf.Fpdf, bill *models.Bill) {
	pdf.Ln(5)
	
	// Draw box for amount
	pdf.SetFillColor(31, 78, 120)
	pdf.SetTextColor(255, 255, 255)
	pdf.SetFont("Arial", "B", 14)
	
	amountText := fmt.Sprintf("Total Amount: %s %.2f", bill.Currency, bill.Amount)
	pdf.CellFormat(0, 12, amountText, "1", 1, "C", true, 0, "")
	
	pdf.SetTextColor(0, 0, 0) // Reset color
	pdf.Ln(5)
}

// addQRCode adds QR code for verification
func (s *PDFService) addQRCode(pdf *gofpdf.Fpdf, billNumber string) error {
	// Generate QR code using existing utility
	qrCodeBase64, err := utils.GenerateQRCode(billNumber, s.frontendURL)
	if err != nil {
		return err
	}
	
	// Decode base64 to image
	// Note: gofpdf needs image file or []byte in specific format
	// For simplicity, we'll add QR as text. In production, decode base64 and add as image
	
	pdf.Ln(3)
	pdf.SetFont("Arial", "B", 11)
	pdf.Cell(0, 6, "Scan to Verify:")
	pdf.Ln(6)
	
	pdf.SetFont("Arial", "", 8)
	verifyURL := fmt.Sprintf("%s/verify/%s", s.frontendURL, billNumber)
	pdf.Cell(0, 5, verifyURL)
	pdf.Ln(8)
	
	// TODO: Actually render QR code image when we have proper image handling
	// For now, we're showing the URL
	_ = qrCodeBase64 // Use the variable to avoid unused error
	
	return nil
}

// addFooter adds footer with verification info
func (s *PDFService) addFooter(pdf *gofpdf.Fpdf, bill *models.Bill) {
	pdf.Ln(5)
	
	// Verification info box
	pdf.SetDrawColor(200, 200, 200)
	pdf.SetFillColor(250, 250, 250)
	
	currentY := pdf.GetY()
	pdf.Rect(20, currentY, 170, 25, "FD")
	
	pdf.SetY(currentY + 3)
	pdf.SetFont("Arial", "B", 10)
	pdf.Cell(0, 6, "Bill Verification Information")
	pdf.Ln(6)
	
	pdf.SetFont("Arial", "", 8)
	pdf.MultiCell(0, 4, fmt.Sprintf(
		"This bill is registered in the Electronic Public Records (EPR) system.\n"+
		"Verify authenticity at: %s/verify/%s\n"+
		"Bill Hash: %s\n"+
		"Generated on: %s",
		s.frontendURL,
		bill.BillNumber,
		bill.DataHash[:16]+"...", // Show first 16 chars of hash
		time.Now().Format("02 Jan 2006 15:04:05 MST"),
	), "", "L", false)
}

// Helper functions

func (s *PDFService) formatBillType(billType models.BillType) string {
	switch billType {
	case models.BillTypeSalarySlip:
		return "SALARY SLIP"
	case models.BillTypeSalesInvoice:
		return "SALES INVOICE"
	case models.BillTypeMedicalBill:
		return "MEDICAL BILL"
	case models.BillTypePurchaseInvoice:
		return "PURCHASE INVOICE"
	case models.BillTypeRentalAgreement:
		return "RENTAL AGREEMENT"
	case models.BillTypeEducationFee:
		return "EDUCATION FEE RECEIPT"
	case models.BillTypeRentReceipt:
		return "RENT RECEIPT"
	case models.BillTypeReimbursement:
		return "REIMBURSEMENT RECEIPT"
	case models.BillTypeLoanStatement:
		return "LOAN STATEMENT"
	case models.BillTypeTaxReceipt:
		return "TAX RECEIPT"
	case models.BillTypeInsurancePolicy:
		return "INSURANCE POLICY"
	default:
		return "BILL"
	}
}

func (s *PDFService) formatFieldName(key string) string {
	// Convert snake_case to Title Case
	result := ""
	capitalize := true
	
	for _, char := range key {
		if char == '_' {
			result += " "
			capitalize = true
		} else if capitalize {
			result += string(char - 32) // Convert to uppercase
			capitalize = false
		} else {
			result += string(char)
		}
	}
	
	return result
}

func (s *PDFService) getStringValue(data map[string]interface{}, keys ...string) string {
	for _, key := range keys {
		if val, exists := data[key]; exists && val != nil {
			return fmt.Sprintf("%v", val)
		}
	}
	return ""
}

func (s *PDFService) getFloatValue(data map[string]interface{}, keys ...string) float64 {
	for _, key := range keys {
		if val, exists := data[key]; exists && val != nil {
			switch v := val.(type) {
			case float64:
				return v
			case float32:
				return float64(v)
			case int:
				return float64(v)
			case int64:
				return float64(v)
			}
		}
	}
	return 0.0
}